#!/usr/bin/env node

var fs = require('fs'),
    path = require('path'),
    argv = require('optimist').argv,
    Table = require('cli-table'),
    ddocs = require('../ddocs'),
    matrix = require('../matrix'),
    weights = require('../weights');

var registry = argv.r || 'http://localhost:5984/registry',
    package  = argv.p || 'winston'

ddocs.seed({
  registry: registry
}, function (err) {
  if (err) {
    throw err;
  }

  matrix({
    package: package,
    registry: registry,
    //
    // TODO: Parameterized this
    //
    top: 10
  }, function (err, codeps, pkg) {
    if (err) {
      throw err;
    }

    function dump(name, relate) {
      Object.keys(relate).forEach(function (codep) {
        if (codep === 'total') { return; }
        console.log('%s | %d %s %s', name, relate[codep].count, codep, relate[codep].relative)
      });
    }

    function values (relate) {
      return Object.keys(relate).map(function (name) {
        return relate[name].count;
      });
    }

    var names  = Object.keys(codeps).sort().filter(function (n) { return n !== 'total' }),
        matrix = [];

    console.log(names);
    dump(package, pkg);
    names.forEach(function (name) {
      console.log();
      dump(name, codeps[name]);
    });

    //
    // For each of the codeps in rows
    // return an Array of values for only
    // it's peers
    //
    names.forEach(function (name) {
      var row = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

      names.forEach(function (coname) {
        if (name === coname) { return }

        var index = names.indexOf(coname);
        if (index !== -1 && codeps[name][coname])  {
          row[index] = codeps[name][coname].count
            * (codeps[name][coname].count / codeps[name].total)
            * pkg[name].relative;
        }
      });

      matrix.push(row);
    });


    //
    // TODO: Remove this debug logging.
    //
    var table = new Table(),
        display = matrix.reduce(function (copy, row) {
          copy.push(row.slice());
          return copy;
        }, []);
    console.dir(display);
    display.forEach(function (row, i) {
      for (var j = 0; j < row.length; j++) {
        row[j] = row[j].toFixed(6);
      }
      row.unshift(names[i]);
    });
    display.unshift(names.slice())
    display[0].unshift('');

    table.push.apply(table, display);
    console.log(table.toString());

    // function logRatio(x, y) {
    //   console.log(
    //     '(%s, %s) %s/%s = %s/%s = %s',
    //     x, y,
    //     display[0][x], display[y][0],
    //     display[x][y], display[y][x],
    //     (display[x][y]/display[y][x]).toFixed(2)
    //   );
    // }

    // for (var i = 1; i < display.length; i++) {
    //   for (var j = 1; j < display.length; j++) {
    //     if (i !== j) {
    //       logRatio(i,j);
    //       logRatio(j,i);
    //       console.log();
    //     }
    //   }
    // }

    //
    // ### Dump the whole JSON
    //
    fs.writeFile(
      path.join(__dirname, '..', 'samples', package + '.json'),
      JSON.stringify({
        codependencies: codeps,
        package: pkg
      }, null, 2),
      'utf8',
      console.log
    );

    fs.writeFile(
      path.join(__dirname, '..', 'samples', package + '-display.json'),
      JSON.stringify({
        names: names,
        matrix: matrix
      }, null, 2),
      'utf8',
      console.log
    );

    //
    // But also dump the matrix
    //

  });
});
