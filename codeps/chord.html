<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="style.css">
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

// TODO: dynamically size?
var outerRadius = 800 / 2,
    innerRadius = outerRadius - 100;

var fill = d3.scale.category20c();

var chord = d3.layout.chord()
    .padding(.04)
    .sortSubgroups(d3.descending)
    .sortChords(d3.descending);

var arc = d3.svg.arc()
    .innerRadius(innerRadius)
    .outerRadius(innerRadius + 20);

var svg = d3.select("body")
  .append("svg")
    .attr("width", outerRadius * 2)
    .attr("height", outerRadius * 2)
  .append("g")
    .attr("transform", "translate(" + outerRadius + "," + outerRadius + ")");

//d3.json("readme.json", function(error, imports) {
setTimeout(function () {
  var matrix = [],
      n = 0;

  //
  // TODO: Dont' use hard-coded values.
  //
  var names = [
  'async',
  'colors',
  'commander',
  'express',
  'lodash',
  'moment',
  'optimist',
  'redis',
  'request',
  'underscore'];

  chord.matrix(
[ [ 0,
    8.004209576787192,
    10.600787245529032,
    10.449078471704947,
    14.347549766628171,
    3.4119439907607987,
    9.743393492923675,
    1.8709382025927168,
    23.93749188494735,
    63.1054170966221 ],
  [ 5.709417317592229,
    0,
    5.545463137996219,
    1.2338606127617076,
    0.8341507056151989,
    0.33363590969076573,
    3.8027279428374414,
    0.04506485477523749,
    2.3877548715388,
    4.017474527707434 ],
  [ 8.111779023279473,
    5.948979591836735,
    0,
    3.1120309759123774,
    0.9339622641509434,
    0.4694780777440256,
    0.08795523800016163,
    0.04183364470875702,
    2.744705429341548,
    7.124374278013092 ],
  [ 13.141444843062569,
    2.1754940017463267,
    5.1148281196613645,
    0,
    1.567687835609042,
    1.2419116375401256,
    4.236938401899869,
    1.2565653354086783,
    5.72504075817589,
    18.044417448084737 ],
  [ 14.128018277070943,
    1.1515285054030278,
    1.2018626659313822,
    1.2274334961463216,
    0,
    0.8293360446947913,
    0.9271444702669345,
    0.12519613056551254,
    2.947912973831751,
    0.017798643662767035 ],
  [ 4.153069588151755,
    0.5693335362142422,
    0.746800568066545,
    1.2019679448163927,
    1.0251663623453033,
    0,
    0.31479914790018254,
    0.19231487117062282,
    1.5653033069588151,
    3.9198711706228444 ],
  [ 11.749827331805482,
    6.42899609141996,
    0.13861331742692995,
    4.062639311838759,
    1.1354425014912253,
    0.31187996421059244,
    0,
    0.18496884123944368,
    4.624221030986092,
    8.269990267792673 ],
  [ 3.110214363331028,
    0.10502568408574534,
    0.090882149560407,
    1.660928084559913,
    0.21135779907142155,
    0.2626494122295762,
    0.25498123086041685,
    0,
    0.42992936876420035,
    1.9230662846982118 ],
  [ 20.710013682846032,
    2.8961306173906394,
    3.103269480051851,
    3.9383580673669014,
    2.5900782918402587,
    1.1125843064246252,
    3.317562275175459,
    0.2237525405284299,
    0,
    18.263102725366878 ],
  [ 64.179745385759,
    5.728107284880277,
    9.46891204235311,
    14.591807380368174,
    0.018382930632274905,
    3.2751849322519426,
    6.974532532363144,
    1.176507560465594,
    21.46862195254614,
    0 ] ]
  );

  /* fill arcs */
  var arcs = svg.append("g")
    .selectAll("path")
      .data(chord.groups)
    .enter().append("path")
      .style("fill", function(d) { return fill(d.index); })
      .style("stroke", function(d) { return fill(d.index); })
      .attr("d", arc)
      .on("mouseover", fade(.1, svg))
      .on("mouseout", fade(1, svg));

  /* add module label */
  var text = svg.append("g")
    .selectAll("g")
      .data(chord.groups)
    .enter().append("g")
    .append("text")
      .each(function(d) {
        d.angle = (d.startAngle + d.endAngle) / 2;
      })
      .attr("dy", ".5em")
      .attr("transform", function(d) {
        return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
            + "translate(" + (innerRadius + 26) + ")"
            + (d.angle > Math.PI ? "rotate(180)" : "");
      })
      .style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
      .text(function(d) { return names[d.index]; });

  var chords = svg.append("g")
      .attr("class", "chord")
    .selectAll("path")
      .data(chord.chords)
    .enter().append("path")
      .attr("class", "chord")
      .style("stroke", function(d) { return d3.rgb(fill(d.source.index)).darker(); })
      .style("fill", function(d) { return fill(d.source.index); })
      .attr("d", d3.svg.chord().radius(innerRadius));

}, 100);

d3.select(self.frameElement).style("height", outerRadius * 2 + "px");

/** Returns an event handler for fading a given chord group. */
function fade(opacity, svg) {
  return function(g, i) {
    console.log("FADING");
    svg.selectAll("g.chord path")
        .filter(function(d) {
          return d.source.index != i && d.target.index != i;
        })
      .transition()
        .style("opacity", opacity);
  };
}
</script>
