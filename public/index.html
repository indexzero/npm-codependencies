<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="style.css">
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

// TODO: dynamically size?
var packageParts = /\?p=([\w\.\-\_]+)$/.exec(window.location),
    packageName  = (packageParts && packageParts[1]) || 'winston'
    outerRadius  = 800 / 2,
    innerRadius  = outerRadius - 100;

var fill = d3.scale.category20c();

var chord = d3.layout.chord()
    .padding(.08)
    .sortSubgroups(d3.descending)
    .sortChords(d3.descending);

var arc = d3.svg.arc()
    .innerRadius(innerRadius)
    .outerRadius(innerRadius + 20);

var svg = d3.select("body")
  .append("svg")
    .attr("width", outerRadius * 4)
    .attr("height", outerRadius * 2);

svg.append("text")
  .attr('transform', 'translate(20,60)')
  .attr("font-size", "60px")
  .attr("text-decoration", "underline")
  .attr('fill', d3.rgb('#333'))
  .text(packageName);

var graph = svg.append("g")
  .attr("transform", "translate(" + outerRadius*1.25 + "," + outerRadius + ")");


d3.json("samples/" + packageName + '-display.json', function(error, display) {
  var names  = display.names,
      matrix = [],
      n = 0;

  chord.matrix(
    display.matrix
  );

  /* fill arcs */
  var arcs = graph.append("g")
      .attr("class", "arcs")
    .selectAll("path")
      .data(chord.groups)
    .enter().append("path")
      .style("fill", function(d) { return fill(d.index); })
      .style("stroke", function(d) { return fill(d.index); })
      .attr("d", arc)
      .on("mouseover", fade(.1, svg))
      .on("mouseout", fade(1, svg));

  /* add module label */
  var labels = graph.append("g")
      .attr("class", "labels")
    .selectAll("g")
      .data(chord.groups)
    .enter().append("g")
    .append("text")
      .each(function(d) {
        d.angle = (d.startAngle + d.endAngle) / 2;
      })
      .attr("dy", ".15em")
      .attr("transform", function(d) {
        return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
            + "translate(" + (innerRadius + 26) + ")"
            + (d.angle > Math.PI ? "rotate(180)" : "");
      })
      .style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
      .text(function(d) { return names[d.index]; });

  var chords = graph.append("g")
      .attr("class", "chords")
    .selectAll("path")
      .data(chord.chords)
    .enter().append("path")
      .attr("class", "chord")
      .style("stroke", function(d) { return d3.rgb(fill(d.source.index)).darker(); })
      .style("fill", function(d) { return fill(d.source.index); })
      .attr("d", d3.svg.chord().radius(innerRadius));

}, 100);

d3.select(self.frameElement).style("height", outerRadius * 2 + "px");

/** Returns an event handler for fading a given chord group. */
function fade(opacity, svg) {
  return function(g, i) {
    graph.selectAll("g.chords path")
      .filter(function(d) {
        return d.source.index != i && d.target.index != i;
      })
      .transition()
        .duration(150)
        .style("opacity", opacity);
  };
}
</script>
